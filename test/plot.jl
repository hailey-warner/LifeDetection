# Tikz Plots:
PLOT_CPDS     = false #true
PLOT_BN       = false #true
DECISION_TREE = false #true

# WANDB Plots:
ALPHA_VECTORS_HEATMAP   = false #true # TODO: need to download pomdpx file to do this
PARETO_FRONTIER = true
projname = "hailey"

using Pkg
if PLOT_BN || PLOT_CPDS || DECISION_TREE
	Pkg.activate("LifeDetectionPkg")
	Pkg.instantiate()
	include("../src/common/plotting_tikz.jl")
	include("../src/bayes_net.jl")
elseif PARETO_FRONTIER
	Pkg.activate("wandbPkg")
	Pkg.instantiate()
	include("../src/common/plotting_wandb.jl")
end




if PARETO_FRONTIER

	using Wandb
	api = Wandb.wandb.Api()

	# Replace with your actual entity (user or team name)
	entity = "sherpa-rpa"

	# Get all projects under the entity
	projects = api.projects(entity=entity)
	# Filter projects whose names start with projname
	filtered_projects = [project for project in projects if startswith(string(project.name), projname)]
	println("Filtered projects: ", [string(project.name) for project in filtered_projects])


	ignore = ["hailey_lambda_0.99_tau_0.05_gamma_0.9_sample_100",
			  "hailey_lambda_0.925_tau_0.5_gamma_0.9_sample_100"]
	filtered_projects = [project for project in filtered_projects if !(string(project.name) in ignore)]
	pareto_count = length(filtered_projects)
	# project_counts = collect(projects)

	# # Count the number of projects that start with "pareto_"
	# pareto_count = count(project_count -> startswith(string(project_count.name), projname), project_counts)

	average_tt = zeros(Float64,pareto_count)
	average_ft = zeros(Float64,pareto_count)
	average_tf = zeros(Float64,pareto_count)
	average_ff = zeros(Float64,pareto_count)

	for (proj_idx, project) in enumerate(filtered_projects)
		if startswith(string(project.name), projname) && !(string(project.name) in ignore)
			# Combine the entity and project name into a single string
			project_path = string(entity, "/", project.name)
			runs_pareto = api.runs(project_path)

			count = 0
			temp_tt = 0.0
			temp_tf = 0.0
			temp_ft = 0.0
			temp_ff = 0.0
			for idx in 1:length(runs_pareto)-1
				if string(runs_pareto[idx].state) == "finished" 
					# print(idx)
					try
						tt = parse(Int, string(runs_pareto[idx].summary["tt"]))
						tf = parse(Int, string(runs_pareto[idx].summary["tf"]))
						ft = parse(Int, string(runs_pareto[idx].summary["ft"]))
						ff = parse(Int, string(runs_pareto[idx].summary["ff"]))

						total_t = tt + tf
						temp_tt += tt / total_t
						temp_tf += tf / total_t

						total_f = ft + ff
						temp_ft += ft / total_f
						temp_ff += ff / total_f

						count += 1
					catch
						println("Run doesn't have the correct metrics / data")
					end
				end
			end 

			if count > 0
				average_tt[proj_idx] = temp_tt / count
				average_tf[proj_idx] = temp_tf / count
				average_ft[proj_idx] = temp_ft / count
				average_ff[proj_idx] = temp_ff / count
			else
				println("Count = 0")
			end

		end
	end

	# Scatter plot 1: average_tt vs average_tf
	p1 = scatter(
		average_tf, average_ft,
		xlabel = "false negative: declared dead when life is true",
		ylabel = "false positive: declared life when life is false",
		# title = "Average TT vs Average TF",
		label = "Projects",
		ylimits=(-0.1,0.1),
		xlimits=(0.5,0.7)

	)

	savefig(p1, "./figures/pareto_scatter.png")
	display(p1)
	println(average_tf)
	println(average_ft)

end

if PLOT_BN == true
	plot = BayesNets.plot(bn)
	if !isdir("figures")
		mkpath("figures")
	end
	TikzPictures.save(SVG("figures/bayes_net_autogenerated.pdf"), plot)
end

if PLOT_CPDS == true
    @eval begin
		p = @pgf GroupPlot({
			group_style = {group_size = "6 by 4", horizontal_sep = "2.5cm", vertical_sep = "2.5cm"},
			width = "4cm",
			height = "3cm",
		})

		# 1: P(life) prior figure
		prior_plot = make_pgfplot(bn.cpds[bn.name_to_index[:C0]].distributions[1], raw"P($C_0$)")
		PGFPlotsX.pgfsave("figures/prior.png", prior_plot)

		# 2: CPD figure
		push!(p, make_pgfplot(bn.cpds[bn.name_to_index[:C1]].distributions[1], raw"P($C_1$ | $C_0$=false)"))
		push!(p, make_pgfplot(bn.cpds[bn.name_to_index[:C1]].distributions[2], raw"P($C_1$ | $C_0$=true)"))
		push!(p, make_pgfplot(bn.cpds[bn.name_to_index[:C2]].distributions[1], raw"P($C_2$ | $C_0$=false)"))
		push!(p, make_pgfplot(bn.cpds[bn.name_to_index[:C2]].distributions[2], raw"P($C_2$ | $C_0$=true)"))
		push!(p, make_pgfplot(bn.cpds[bn.name_to_index[:C3]].distributions[1], raw"P($C_3$ | $C_0$=false)"))
		push!(p, make_pgfplot(bn.cpds[bn.name_to_index[:C3]].distributions[2], raw"P($C_3$ | $C_0$=true)"))

		push!(p, make_pgfplot(bn.cpds[bn.name_to_index[:C4]].distributions[1], raw"P($C_4$ | $C_0$=false)"))
		push!(p, make_pgfplot(bn.cpds[bn.name_to_index[:C4]].distributions[2], raw"P($C_4$ | $C_0$=true)"))
		push!(p, make_pgfplot(bn.cpds[bn.name_to_index[:C5]].distributions[1], raw"P($C_5$ | $C_0$=false)"))
		push!(p, make_pgfplot(bn.cpds[bn.name_to_index[:C5]].distributions[2], raw"P($C_5$ | $C_0$=true)"))
		push!(p, make_pgfplot(bn.cpds[bn.name_to_index[:C6]].distributions[1], raw"P($C_6$ | $C_0$=false)"))
		push!(p, make_pgfplot(bn.cpds[bn.name_to_index[:C6]].distributions[2], raw"P($C_6$ | $C_0$=true)"))

		push!(p, make_pgfplot(bn.cpds[bn.name_to_index[:C7]].distributions[1], raw"P($C_7$ | $C_2$=false)"))
		push!(p, make_pgfplot(bn.cpds[bn.name_to_index[:C7]].distributions[2], raw"P($C_7$ | $C_2$=true)"))
		push!(p, make_pgfplot(bn.cpds[bn.name_to_index[:C8]].distributions[1], raw"P($C_8$ | $C_4$=false, $C_5$=0)"))
		push!(p, make_pgfplot(bn.cpds[bn.name_to_index[:C8]].distributions[23], raw"P($C_8$ | $C_4$=false, $C_5$=22)"))
		push!(p, make_pgfplot(bn.cpds[bn.name_to_index[:C8]].distributions[24], raw"P($C_8$ | $C_4$=true, $C_5$=0)"))
		push!(p, make_pgfplot(bn.cpds[bn.name_to_index[:C8]].distributions[46], raw"P($C_8$ | $C_4$=true, $C_5$=22)"))

		push!(p, make_pgfplot(bn.cpds[bn.name_to_index[:C9]].distributions[1], raw"P($C_9$ | $C_1$=false, $C_5$=0)"))
		push!(p, make_pgfplot(bn.cpds[bn.name_to_index[:C9]].distributions[23], raw"P($C_9$ | $C_1$=false, $C_5$=22)"))
		push!(p, make_pgfplot(bn.cpds[bn.name_to_index[:C9]].distributions[24], raw"P($C_9$ | $C_1$=true, $C_5$=0)"))
		push!(p, make_pgfplot(bn.cpds[bn.name_to_index[:C9]].distributions[46], raw"P($C_9$ | $C_1$=true, $C_5$=22)"))
		push!(p, make_pgfplot(bn.cpds[bn.name_to_index[:C10]].distributions[1], raw"P($C_{10}$ | $C_5$=0)"))
		push!(p, make_pgfplot(bn.cpds[bn.name_to_index[:C10]].distributions[23], raw"P($C_{10}$ | $C_5$=22)"))

		PGFPlotsX.pgfsave("figures/cpds.png", p)
	end
end




# if DECISION_TREE == true
#     tree_data = make_decision_tree(pomdp, policy)
#     plot_decision_tree(tree_data)
# end
# if ALPHA_VECTORS == true
#     plot_alpha_vectors(policy)
# end

# if PARETO_FRONTIER == true
#     end_λ = 20
#     reward_list = []
#     acc_list = []
#     for λ in range(1, end_λ)
#         pomdp = binaryLifeDetectionPOMDP(inst=NUM_INSTRUMENTS, bn=bn, λ=λ,  k=SENSOR_COST, discount=0.9)
#         solver = SARSOPSolver(verbose=true, timeout=100)
#         policy = solve(solver, pomdp)
#         rewards, accuracy = simulate_policy(pomdp, policy, "SARSOP", 200, verbose=false) # SARSOP or greedy
#         push!(reward_list, rewards)
#         push!(acc_list, accuracy)
#     end
#     x = range(1, end_λ)
#     p1 = scatter(x, reward_list, color=:blue, xlabel="λ", ylabel="Reward Value", title="Reward", label="rewards")
#     p2 = scatter(x, acc_list, color=:red, xlabel="λ", ylabel="Accuracy (0 to 1)", title="Accuracy", label="Accuracy")
#     p = Plots.plot(p1, p2, layout=(1, 2), size=(800, 400), title="Pareto Frontier")
#     savefig(p, "./figures/pareto_frontier.png")
# end

# # @show_requirements POMDPs.solve(solver, pomdp)
